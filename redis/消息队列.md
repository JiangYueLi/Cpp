# 发布订阅模式

subscribe channel：普通订阅
publish channel message：消息推送
psubscribe pattern：主题订阅
unsubscribe channel：取消普通订阅
punsubscribe pattern：取消主题订阅

使用它们之后就可以完成单个频道和多个频道的消息收发，但发送与订阅模式也有一些缺点，比如“发后既忘”和不能持久化等问题，然而这些问题会等到 Stream 类型的出现而得到解决

List 方式是实现消息队列最简单和最直接的方式，它主要是通过 lpush 和 rpop 存入和读取实现消息队列的
优点
消息可以被持久化，借助 Redis 本身的持久化（AOF、RDB 或者是混合持久化），可以有效的保存数据；
消费者可以积压消息，不会因为客户端的消息过多而被强行断开。
缺点
消息不能被重复消费，一个消息消费完就会被删除；
没有主题订阅的功能。

ZSet 版消息队列
相比于之前的List 和发布订阅方式，ZSet 版消息队列在实现上要复杂一些，但 ZSet 因为多了一个 score（分值）属性，从而使它具备更多的功能，例如我们可以用它来存储时间戳，以此来实现延迟消息队列等。
它的实现思路和 List 相同也是利用 zadd 和 zrangebyscore 来实现存入和读取，这里就不重复叙述了，可以根据 List 的实现方式来实践一下，看能不能实现相应的功能。如果写不出来也没关系，我们会在后面学习延迟队列，到时候会用 ZSet 来实现。
优点
支持消息持久化；
相比于 List 查询更方便，ZSet 可以利用 score 属性很方便的完成检索，而 List 则需要遍历整个元素才能检索到某个值。
缺点
ZSet 不能存储相同元素的值，也就是如果有消息是重复的，那么只能插入一条信息在有序集合中；
ZSet 是根据 score 值排序的，不能像 List 一样，按照插入顺序来排序；
ZSet 没有向 List 的 brpop 那样的阻塞弹出的功能。


消息队列的终极解决方案--stream
Stream 既然是一个数据类型，那么和其他数据类型相似，它也有一些自己的操作方法，例如：
xadd：添加消息；
xlen：查询消息的长度；
xdel：根据消息ID删除消息；
del：删除整个stream，当然del可以删除任意的key；
xrange：读取区间消息；
xread：读取某个消息之后的消息；